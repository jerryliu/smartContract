{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-core-helpers'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/inherits'), require('@babel/runtime/helpers/assertThisInitialized'), require('lodash/isFunction'), require('lodash/isBoolean'), require('eth-lib/lib/rlp'), require('eth-lib/lib/bytes'), require('web3-core'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('scrypt.js'), require('lodash/isString'), require('lodash/isObject'), require('eth-lib/lib/account'), require('uuid'), require('eth-lib/lib/hash'), require('web3-utils'), require('web3-providers'), require('web3-core-method')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-core-helpers', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits', '@babel/runtime/helpers/assertThisInitialized', 'lodash/isFunction', 'lodash/isBoolean', 'eth-lib/lib/rlp', 'eth-lib/lib/bytes', 'web3-core', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', 'scrypt.js', 'lodash/isString', 'lodash/isObject', 'eth-lib/lib/account', 'uuid', 'eth-lib/lib/hash', 'web3-utils', 'web3-providers', 'web3-core-method'], factory) : factory(global.Web3EthAccounts = {}, global.web3CoreHelpers, global._regeneratorRuntime, global._asyncToGenerator, global._possibleConstructorReturn, global._getPrototypeOf, global._inherits, global._assertThisInitialized, global.isFunction, global.isBoolean, global.RLP, global.Bytes, global.web3Core, global._classCallCheck, global._createClass, global.scryptsy, global.isString, global.isObject, global.account, global.uuid, global.Hash, global.Utils, global.web3Providers, global.web3CoreMethod);\n})(this, function (exports, web3CoreHelpers, _regeneratorRuntime, _asyncToGenerator, _possibleConstructorReturn, _getPrototypeOf, _inherits, _assertThisInitialized, isFunction, isBoolean, RLP, Bytes, web3Core, _classCallCheck, _createClass, scryptsy, isString, isObject, account, uuid, Hash, Utils, web3Providers, web3CoreMethod) {\n  'use strict';\n\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  _assertThisInitialized = _assertThisInitialized && _assertThisInitialized.hasOwnProperty('default') ? _assertThisInitialized['default'] : _assertThisInitialized;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  isBoolean = isBoolean && isBoolean.hasOwnProperty('default') ? isBoolean['default'] : isBoolean;\n  RLP = RLP && RLP.hasOwnProperty('default') ? RLP['default'] : RLP;\n  Bytes = Bytes && Bytes.hasOwnProperty('default') ? Bytes['default'] : Bytes;\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  scryptsy = scryptsy && scryptsy.hasOwnProperty('default') ? scryptsy['default'] : scryptsy;\n  isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;\n  Hash = Hash && Hash.hasOwnProperty('default') ? Hash['default'] : Hash;\n  var crypto = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\n  var Account = function () {\n    function Account(options) {\n      var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, Account);\n\n      this.address = options.address;\n      this.privateKey = options.privateKey;\n      this.accounts = accounts;\n      return new Proxy(this, {\n        get: function get(target, name) {\n          return target[name];\n        }\n      });\n    }\n\n    _createClass(Account, [{\n      key: \"signTransaction\",\n      value: function signTransaction(tx, callback) {\n        return this.accounts.signTransaction(tx, this.privateKey, callback);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(data) {\n        if (Utils.isHexStrict(data)) {\n          data = Utils.hexToBytes(data);\n        }\n\n        var messageBuffer = Buffer.from(data);\n        var preamble = \"\\x19Ethereum Signed Message:\\n\".concat(data.length);\n        var preambleBuffer = Buffer.from(preamble);\n        var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n        var hash = Hash.keccak256s(ethMessage);\n        var signature = account.sign(hash, this.privateKey);\n        var vrs = account.decodeSignature(signature);\n        return {\n          message: data,\n          messageHash: hash,\n          v: vrs[0],\n          r: vrs[1],\n          s: vrs[2],\n          signature: signature\n        };\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(password, options) {\n        return Account.fromPrivateKey(this.privateKey, this.accounts.transactionSinger).toV3Keystore(password, options);\n      }\n    }, {\n      key: \"toV3Keystore\",\n      value: function toV3Keystore(password, options) {\n        options = options || {};\n        var salt = options.salt || crypto.randomBytes(32);\n        var iv = options.iv || crypto.randomBytes(16);\n        var derivedKey;\n        var kdf = options.kdf || 'scrypt';\n        var kdfparams = {\n          dklen: options.dklen || 32,\n          salt: salt.toString('hex')\n        };\n\n        if (kdf === 'pbkdf2') {\n          kdfparams.c = options.c || 262144;\n          kdfparams.prf = 'hmac-sha256';\n          derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n        } else if (kdf === 'scrypt') {\n          kdfparams.n = options.n || 8192;\n          kdfparams.r = options.r || 8;\n          kdfparams.p = options.p || 1;\n          derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else {\n          throw new Error('Unsupported kdf');\n        }\n\n        var cipher = crypto.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n        if (!cipher) {\n          throw new Error('Unsupported cipher');\n        }\n\n        var ciphertext = Buffer.concat([cipher.update(Buffer.from(this.privateKey.replace('0x', ''), 'hex')), cipher.final()]);\n        var mac = Utils.sha3(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')])).replace('0x', '');\n        return {\n          version: 3,\n          id: uuid.v4({\n            random: options.uuid || crypto.randomBytes(16)\n          }),\n          address: this.address.toLowerCase().replace('0x', ''),\n          crypto: {\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n              iv: iv.toString('hex')\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf: kdf,\n            kdfparams: kdfparams,\n            mac: mac.toString('hex')\n          }\n        };\n      }\n    }], [{\n      key: \"from\",\n      value: function from(entropy) {\n        var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new Account(account.create(entropy || Utils.randomHex(32)), accounts.transactionSigner);\n      }\n    }, {\n      key: \"fromPrivateKey\",\n      value: function fromPrivateKey(privateKey) {\n        var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new Account(account.fromPrivate(privateKey), accounts.transactionSigner);\n      }\n    }, {\n      key: \"fromV3Keystore\",\n      value: function fromV3Keystore(v3Keystore, password) {\n        var nonStrict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var accounts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        if (!isString(password)) {\n          throw new Error('No password given.');\n        }\n\n        var json = isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n        if (json.version !== 3) {\n          throw new Error('Not a valid V3 wallet');\n        }\n\n        var derivedKey;\n        var kdfparams;\n\n        if (json.crypto.kdf === 'scrypt') {\n          kdfparams = json.crypto.kdfparams;\n          derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else if (json.crypto.kdf === 'pbkdf2') {\n          kdfparams = json.crypto.kdfparams;\n\n          if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n          }\n\n          derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n        } else {\n          throw new Error('Unsupported key derivation scheme');\n        }\n\n        var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n        var mac = Utils.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n        if (mac !== json.crypto.mac) {\n          throw new Error('Key derivation failed - possibly wrong password');\n        }\n\n        var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n        var seed = \"0x\".concat(Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex'));\n        return this.fromPrivateKey(seed, accounts);\n      }\n    }]);\n\n    return Account;\n  }();\n\n  var Accounts = function (_AbstractWeb3Module) {\n    _inherits(Accounts, _AbstractWeb3Module);\n\n    function Accounts(provider, providersModuleFactory, formatters, chainIdMethod, getGasPriceMethod, getTransactionCountMethod, options) {\n      var _this;\n\n      _classCallCheck(this, Accounts);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Accounts).call(this, provider, providersModuleFactory, null, null, options));\n      _this.transactionSigner = options.transactionSigner;\n      _this.formatters = formatters;\n      _this.chainIdMethod = chainIdMethod;\n      _this.getGasPriceMethod = getGasPriceMethod;\n      _this.getTransactionCountMethod = getTransactionCountMethod;\n      _this.defaultKeyName = 'web3js_wallet';\n      _this.accounts = {};\n      _this.accountsIndex = 0;\n      _this.wallet = _this.createWalletProxy();\n      return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_assertThisInitialized(_this)), {\n        get: function get(target, name) {\n          return target[name];\n        }\n      }));\n    }\n\n    _createClass(Accounts, [{\n      key: \"createWalletProxy\",\n      value: function createWalletProxy() {\n        return new Proxy(this, {\n          get: function get(target, name) {\n            switch (name) {\n              case 'create':\n                return target.addGeneratedAccountsToWallet;\n\n              case 'encrypt':\n                return target.encryptWallet;\n\n              case 'decrypt':\n                return target.decryptWallet;\n\n              case 'clear':\n                return target.clear;\n\n              default:\n                if (target.accounts[name]) {\n                  return target.accounts[name];\n                }\n\n                return target[name];\n            }\n          }\n        });\n      }\n    }, {\n      key: \"addGeneratedAccountsToWallet\",\n      value: function addGeneratedAccountsToWallet(numberOfAccounts, entropy) {\n        var account$$1 = Account.from(entropy || Utils.randomHex(32), this);\n\n        for (var i = 0; i < numberOfAccounts; ++i) {\n          this.add(account$$1);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"add\",\n      value: function add(account$$1) {\n        if (isString(account$$1)) {\n          account$$1 = Account.fromPrivateKey(account$$1, this);\n        }\n\n        if (!this[account$$1.address]) {\n          this.accounts[this.accountsIndex] = account$$1;\n          this.accounts[account$$1.address] = account$$1;\n          this.accounts[account$$1.address.toLowerCase()] = account$$1;\n          this.accountsIndex++;\n          return account$$1;\n        }\n\n        return this.accounts[account$$1.address];\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(addressOrIndex) {\n        var _this2 = this;\n\n        var removed;\n\n        if (this.accounts[addressOrIndex]) {\n          Object.keys(this.accounts).forEach(function (key) {\n            if (_this2.accounts[key].address === addressOrIndex || key === addressOrIndex) {\n              delete _this2.accounts[key];\n              _this2.accountsIndex--;\n              removed = true;\n            }\n          });\n          return !!removed;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.accounts = {};\n        this.accountsIndex = 0;\n        return this;\n      }\n    }, {\n      key: \"encryptWallet\",\n      value: function encryptWallet(password, options) {\n        var _this3 = this;\n\n        var encryptedAccounts = [];\n        Object.keys(this.accounts).forEach(function (key) {\n          return encryptedAccounts.push(_this3.accounts[key].encrypt(password, options));\n        });\n        return encryptedAccounts;\n      }\n    }, {\n      key: \"decryptWallet\",\n      value: function decryptWallet(encryptedWallet, password) {\n        var _this4 = this;\n\n        encryptedWallet.forEach(function (keystore) {\n          var account$$1 = Account.fromV3Keystore(keystore, password, false, _this4);\n\n          if (!account$$1) {\n            throw new Error(\"Couldn't decrypt accounts. Password wrong?\");\n          }\n\n          _this4.add(account$$1);\n        });\n        return this;\n      }\n    }, {\n      key: \"save\",\n      value: function save(password, keyName) {\n        if (typeof localStorage === 'undefined') {\n          throw new TypeError('window.localStorage is undefined.');\n        }\n\n        try {\n          localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encryptWallet(password)));\n        } catch (error) {\n          if (error.code === 18) {\n            return true;\n          }\n\n          throw new Error(error);\n        }\n\n        return true;\n      }\n    }, {\n      key: \"load\",\n      value: function load(password, keyName) {\n        var _this5 = this;\n\n        if (typeof localStorage === 'undefined') {\n          throw new TypeError('window.localStorage is undefined.');\n        }\n\n        var keystore;\n\n        try {\n          keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n          if (keystore) {\n            keystore = JSON.parse(keystore).map(function (item) {\n              return Account.fromV3Keystore(item, password, false, _this5);\n            });\n          }\n        } catch (error) {\n          if (error.code === 18) {\n            keystore = this.defaultKeyName;\n          } else {\n            throw new Error(error);\n          }\n        }\n\n        return this.decryptWallet(keystore || [], password);\n      }\n    }, {\n      key: \"create\",\n      value: function create(entropy) {\n        return Account.from(entropy, this);\n      }\n    }, {\n      key: \"privateKeyToAccount\",\n      value: function privateKeyToAccount(privateKey) {\n        return Account.fromPrivateKey(privateKey, this);\n      }\n    }, {\n      key: \"hashMessage\",\n      value: function hashMessage(data) {\n        if (Utils.isHexStrict(data)) {\n          data = Utils.hexToBytes(data);\n        }\n\n        var messageBuffer = Buffer.from(data);\n        var preamble = \"\\x19Ethereum Signed Message:\\n\".concat(data.length);\n        var preambleBuffer = Buffer.from(preamble);\n        var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n        return Hash.keccak256s(ethMessage);\n      }\n    }, {\n      key: \"signTransaction\",\n      value: function () {\n        var _signTransaction = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tx, privateKey, callback) {\n          var account$$1, signedTransaction;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  account$$1 = Account.fromPrivateKey(privateKey, this);\n\n                  if (tx.chainId) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  _context.next = 5;\n                  return this.chainIdMethod.execute(this);\n\n                case 5:\n                  tx.chainId = _context.sent;\n\n                case 6:\n                  if (tx.gasPrice) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  _context.next = 9;\n                  return this.getGasPriceMethod.execute(this);\n\n                case 9:\n                  tx.gasPrice = _context.sent;\n\n                case 10:\n                  if (tx.nonce) {\n                    _context.next = 15;\n                    break;\n                  }\n\n                  this.getTransactionCountMethod.parameters = [account$$1.address];\n                  _context.next = 14;\n                  return this.getTransactionCountMethod.execute(this);\n\n                case 14:\n                  tx.nonce = _context.sent;\n\n                case 15:\n                  _context.next = 17;\n                  return this.transactionSigner.sign(tx, account$$1.privateKey);\n\n                case 17:\n                  signedTransaction = _context.sent;\n\n                  if (isFunction(callback)) {\n                    callback(false, signedTransaction);\n                  }\n\n                  return _context.abrupt(\"return\", signedTransaction);\n\n                case 22:\n                  _context.prev = 22;\n                  _context.t0 = _context[\"catch\"](0);\n\n                  if (isFunction(callback)) {\n                    callback(_context.t0, null);\n                  }\n\n                  throw _context.t0;\n\n                case 26:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 22]]);\n        }));\n\n        return function signTransaction(_x, _x2, _x3) {\n          return _signTransaction.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"recoverTransaction\",\n      value: function recoverTransaction(rawTx) {\n        var values = RLP.decode(rawTx);\n        var signature = account.encodeSignature(values.slice(6, 9));\n        var recovery = Bytes.toNumber(values[6]);\n        var extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n        var signingData = values.slice(0, 6).concat(extraData);\n        var signingDataHex = RLP.encode(signingData);\n        return account.recover(Hash.keccak256(signingDataHex), signature);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(data, privateKey) {\n        if (Utils.isHexStrict(data)) {\n          data = Utils.hexToBytes(data);\n        }\n\n        return Account.fromPrivateKey(privateKey, this).sign(data);\n      }\n    }, {\n      key: \"recover\",\n      value: function recover(message, signature, preFixed) {\n        var args = [].slice.apply(arguments);\n\n        if (isObject(message)) {\n          return this.recover(message.messageHash, account.encodeSignature([message.v, message.r, message.s]), true);\n        }\n\n        if (!preFixed) {\n          message = this.hashMessage(message);\n        }\n\n        if (args.length >= 4) {\n          preFixed = args.slice(-1)[0];\n          preFixed = isBoolean(preFixed) ? preFixed : false;\n          return this.recover(message, account.encodeSignature(args.slice(1, 4)), preFixed);\n        }\n\n        return account.recover(message, signature);\n      }\n    }, {\n      key: \"decrypt\",\n      value: function decrypt(v3Keystore, password, nonStrict) {\n        return Account.fromV3Keystore(v3Keystore, password, nonStrict, this);\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(privateKey, password, options) {\n        return Account.fromPrivateKey(privateKey, this).toV3Keystore(password, options);\n      }\n    }]);\n\n    return Accounts;\n  }(web3Core.AbstractWeb3Module);\n\n  var Accounts$1 = function Accounts$$1(provider, options) {\n    return new Accounts(provider, new web3Providers.ProvidersModuleFactory(), web3CoreHelpers.formatters, new web3CoreMethod.ChainIdMethod(Utils, web3CoreHelpers.formatters), new web3CoreMethod.GetGasPriceMethod(Utils, web3CoreHelpers.formatters), new web3CoreMethod.GetTransactionCountMethod(Utils, web3CoreHelpers.formatters), options);\n  };\n\n  exports.Accounts = Accounts$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}